<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>
  File: README
  
    &mdash; Documentation by YARD 0.9.19
  
</title>

  <link rel="stylesheet" href="css/style.css" type="text/css" charset="utf-8" />

  <link rel="stylesheet" href="css/common.css" type="text/css" charset="utf-8" />

<script type="text/javascript" charset="utf-8">
  pathId = "README";
  relpath = '';
</script>


  <script type="text/javascript" charset="utf-8" src="js/jquery.js"></script>

  <script type="text/javascript" charset="utf-8" src="js/app.js"></script>


  </head>
  <body>
    <div class="nav_wrap">
      <iframe id="nav" src="file_list.html?1"></iframe>
      <div id="resizer"></div>
    </div>

    <div id="main" tabindex="-1">
      <div id="header">
        <div id="menu">
  
    <a href="_index.html">Index</a> &raquo; 
    <span class="title">File: README</span>
  
</div>

        <div id="search">
  
    <a class="full_list_link" id="class_list_link"
        href="class_list.html">

        <svg width="24" height="24">
          <rect x="0" y="4" width="24" height="4" rx="1" ry="1"></rect>
          <rect x="0" y="12" width="24" height="4" rx="1" ry="1"></rect>
          <rect x="0" y="20" width="24" height="4" rx="1" ry="1"></rect>
        </svg>
    </a>
  
</div>
        <div class="clear"></div>
      </div>

      <div id="content"><div id='filecontents'><h1>Orocos.rb: deploying and supervising Orocos/RTT modules</h1>

<p>Orocos.rb is a Ruby library which allows to access, read out and control Orocos RTT
(<a href="http://www.orocos.org">http://www.orocos.org</a>) components. It uses the CORBA transport of Orocos for that,
so you need to have the CORBA library installed, as well as the rtt-corba library.</p>

<p>Most intersting features of Orocos.rb, like reading/writing ports and
properties, starting out processes, ... Require the module to be generated by
orogen. This is because of the type handling library that orogen is built on,
and could probably be changed in the future. The rest of the documentation will
assume that the modules you are working on have been orogen-generated.</p>

<p>All script snippets in this documentation are Ruby scripts, and assume that you
have first done:</p>

<pre class="code ruby"><code class="ruby">  <span class='id identifier rubyid_require'>require</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>orocos</span><span class='tstring_end'>&#39;</span></span>
  <span class='id identifier rubyid_include'>include</span> <span class='const'><span class='object_link'><a href="Orocos.html" title="Orocos (module)">Orocos</a></span></span>
</code></pre>

<h2>Installation</h2>

<p>This package is part of the rubim.orocos package set of RubyInMotion. See
<a href="http://sites.google.com/site/rubyinmotion">http://sites.google.com/site/rubyinmotion</a> for installation instructions.</p>

<h2>Starting processes</h2>

<p>As always with orogen, the dependency tracking is done using pkg-config. So make
sure that the PKG_CONFIG_PATH environment variable is set properly: it should
include the <tt>lib/pkgconfig</tt> subdirectory of where you installed the
orogen module.</p>

<p>Then, start your modules with </p>

<pre class="code ruby"><code class="ruby">  <span class='id identifier rubyid_p1'>p1</span><span class='comma'>,</span> <span class='id identifier rubyid_p2'>p2</span> <span class='op'>=</span> <span class='const'><span class='object_link'><a href="Orocos.html" title="Orocos (module)">Orocos</a></span></span><span class='op'>::</span><span class='const'><span class='object_link'><a href="Orocos/Process.html" title="Orocos::Process (class)">Process</a></span></span><span class='period'>.</span><span class='id identifier rubyid_spawn'><span class='object_link'><a href="Orocos/Process.html#spawn-instance_method" title="Orocos::Process#spawn (method)">spawn</a></span></span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>canbus</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>hokuyo</span><span class='tstring_end'>&#39;</span></span>
</code></pre>

<p>where canbus and hokuyo are the names of the processes as deployed by orogen,
i.e. the name given to #deployment in the orogen specification:</p>

<pre class="code ruby"><code class="ruby">  <span class='id identifier rubyid_deployment'>deployment</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>canbus</span><span class='tstring_end'>&#39;</span></span> <span class='kw'>do</span>
    <span class='comment'># Spawn task contexts
</span>  <span class='kw'>end</span>
</code></pre>

<p>Alternatively, you can use the block form. In this form, when the <tt>do ...
end</tt> block is exited, then the processes are properly shut down.</p>

<pre class="code ruby"><code class="ruby">  <span class='const'><span class='object_link'><a href="Orocos.html" title="Orocos (module)">Orocos</a></span></span><span class='op'>::</span><span class='const'><span class='object_link'><a href="Orocos/Process.html" title="Orocos::Process (class)">Process</a></span></span><span class='period'>.</span><span class='id identifier rubyid_spawn'><span class='object_link'><a href="Orocos/Process.html#spawn-instance_method" title="Orocos::Process#spawn (method)">spawn</a></span></span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>canbus</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>hokuyo</span><span class='tstring_end'>&#39;</span></span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_p1'>p1</span><span class='comma'>,</span> <span class='id identifier rubyid_p2'>p2</span><span class='op'>|</span>
    <span class='comment'># Use the process objects.
</span>  <span class='kw'>end</span>
</code></pre>

<p>In both cases, +p1+ and +p2+ refer to Orocos::Process instances that
respectively represent the +canbus+ and +hokuyo+ processes.</p>

<p>See the documentation of Orocos::Process for more details.</p>

<h3>Getting a grasp on existing task contexts</h3>

<p>You can grab an object represeting the remote RTT component with:</p>

<pre class="code ruby"><code class="ruby">  <span class='id identifier rubyid_c'>c</span> <span class='op'>=</span> <span class='const'>TaskContext</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span> <span class='const'>IOR</span>
  <span class='comment'># or 
</span>  <span class='id identifier rubyid_d'>d</span> <span class='op'>=</span> <span class='const'><span class='object_link'><a href="Orocos.html" title="Orocos (module)">Orocos</a></span></span><span class='period'>.</span><span class='id identifier rubyid_name_service'><span class='object_link'><a href="Orocos.html#name_service-class_method" title="Orocos.name_service (method)">name_service</a></span></span><span class='period'>.</span><span class='id identifier rubyid_get'><span class='object_link'><a href="Orocos/NameService.html#get-instance_method" title="Orocos::NameService#get (method)">get</a></span></span> <span class='const'>TaskName</span>
</code></pre>

<p>where TaskName is the name given to the task during deployment and 
IOR the Interoperable Object Reference (IOR). You can list all
existing tasks using the orocos_state script included in orocos.rb.</p>

<p>Alternatively, one can get a task based on the interfaces it implements. In
orogen, this is marked by the class hierarchy (i.e. either directly the task&#39;s
class name or one of its parent class names).</p>

<p>For instance, with the orogen specification looking like:</p>

<pre class="code ruby"><code class="ruby">  name &quot;controldev&quot;
  task_context &quot;Device&quot; do
    ... generic interface definition ...
  end
  task_context &quot;Joystick&quot; do
    subclasses &quot;Device&quot;
    ... specific joystick parts ...
  end
  task_context &quot;Joypad&quot; do
    subclasses &quot;Device&quot;
    ... specific joypad parts ...
  end
  task_context &quot;Remote&quot; do
    subclasses &quot;Device&quot;
    ... specific remote parts ...
  end
</code></pre>

<p>During deployment, you would choose the &quot;right&quot; one for your system. For
instance, a local computer would use controldev::Joystick, the robot would
require a remote control and therefore use controldev::Remote and so on.</p>

<p>Though, the script will be independent from that choice because you can use</p>

<pre class="code ruby"><code class="ruby">  <span class='id identifier rubyid_c'>c</span> <span class='op'>=</span> <span class='const'><span class='object_link'><a href="Orocos.html" title="Orocos (module)">Orocos</a></span></span><span class='period'>.</span><span class='id identifier rubyid_name_service'><span class='object_link'><a href="Orocos.html#name_service-class_method" title="Orocos.name_service (method)">name_service</a></span></span><span class='period'>.</span><span class='id identifier rubyid_get_provides'><span class='object_link'><a href="Orocos/NameServiceBase.html#get_provides-instance_method" title="Orocos::NameServiceBase#get_provides (method)">get_provides</a></span></span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>controldev::Device</span><span class='tstring_end'>&quot;</span></span><span class='rparen'>)</span>
</code></pre>

<p>Orocos.name_service.get_provides returns a Orocos::TaskContext instance. See the
documentation of that class for more details.</p>

<h2>Changing and reading a task context&#39;s state</h2>

<h2>Manipulating a task context</h2>

<p>You can change the task&#39;s properties with:</p>

<pre class="code ruby"><code class="ruby">  # This property is a &quot;simple&quot; type (i.e. not a struct)
  c.device_name = &quot;/dev/ttyUSB0&quot;

  # This one is a struct, so get the component&#39;s default value and change it 
  value = c.parameters
  value.maxSpeed = 20
  value. = 200
  c.propertyName = value
</code></pre>

<p>The properties are represented by Orocos::Attribute objects. In the same way,
ports can be accessed through Orocos::InputPort and Orocos::OutputPort objects:</p>

<pre class="code ruby"><code class="ruby">  <span class='id identifier rubyid_output_port'>output_port</span> <span class='op'>=</span> <span class='id identifier rubyid_c'>c</span><span class='period'>.</span><span class='id identifier rubyid_currentReadings'>currentReadings</span>
  <span class='id identifier rubyid_input_port'>input_port</span>  <span class='op'>=</span> <span class='id identifier rubyid_c'>c</span><span class='period'>.</span><span class='id identifier rubyid_speed'>speed</span>
</code></pre>

<p>Reading/writing these ports is done with:</p>

<pre class="code ruby"><code class="ruby">  <span class='id identifier rubyid_port_reader'>port_reader</span> <span class='op'>=</span> <span class='id identifier rubyid_c'>c</span><span class='period'>.</span><span class='id identifier rubyid_currentReadings'>currentReadings</span><span class='period'>.</span><span class='id identifier rubyid_reader'>reader</span>
  <span class='id identifier rubyid_port_reader'>port_reader</span><span class='period'>.</span><span class='id identifier rubyid_read'>read</span> <span class='comment'># =&gt; returns the current reading instance
</span>
  <span class='id identifier rubyid_port_writer'>port_writer</span> <span class='op'>=</span> <span class='id identifier rubyid_c'>c</span><span class='period'>.</span><span class='id identifier rubyid_speed'>speed</span><span class='period'>.</span><span class='id identifier rubyid_writer'>writer</span>
  <span class='id identifier rubyid_port_writer'>port_writer</span><span class='period'>.</span><span class='id identifier rubyid_write'>write</span><span class='lparen'>(</span><span class='int'>10</span><span class='rparen'>)</span> <span class='comment'># =&gt; returns the current reading instance
</span></code></pre>

<p>If the port&#39;s type is a structure, then you can either do:</p>

<pre class="code ruby"><code class="ruby">  <span class='id identifier rubyid_sample'>sample</span> <span class='op'>=</span> <span class='id identifier rubyid_port_writer'>port_writer</span><span class='period'>.</span><span class='id identifier rubyid_new_sample'>new_sample</span> <span class='comment'># or c.speed.new_sample
</span>  <span class='id identifier rubyid_sample'>sample</span><span class='period'>.</span><span class='id identifier rubyid_value'>value</span> <span class='op'>=</span> <span class='int'>100</span>
  <span class='id identifier rubyid_port_writer'>port_writer</span><span class='period'>.</span><span class='id identifier rubyid_write'>write</span><span class='lparen'>(</span><span class='id identifier rubyid_sample'>sample</span><span class='rparen'>)</span>
</code></pre>

<p>or represent the structure through a hash:</p>

<pre class="code ruby"><code class="ruby">  <span class='id identifier rubyid_port_writer'>port_writer</span><span class='period'>.</span><span class='id identifier rubyid_write'>write</span><span class='lparen'>(</span><span class='symbol'>:value</span> <span class='op'>=&gt;</span> <span class='int'>100</span><span class='rparen'>)</span>
</code></pre>

<p>Orocos::InputPort#writer and Orocos::OutputPort#reader return respectively
Orocos::InputWriter and Orocos::OutputReader objects. These objects are
connected to the remote ports using the standard RTT data flow mechanism, so it
is possible to specify a connection policy:</p>

<pre class="code ruby"><code class="ruby">  <span class='id identifier rubyid_port_reader'>port_reader</span> <span class='op'>=</span> <span class='id identifier rubyid_c'>c</span><span class='period'>.</span><span class='id identifier rubyid_currentReadings'>currentReadings</span><span class='period'>.</span><span class='id identifier rubyid_reader'>reader</span><span class='lparen'>(</span><span class='symbol'>:type</span> <span class='op'>=&gt;</span> <span class='symbol'>:buffer</span><span class='comma'>,</span> <span class='symbol'>:size</span> <span class='op'>=&gt;</span> <span class='int'>10</span><span class='comma'>,</span> <span class='symbol'>:pull</span> <span class='op'>=&gt;</span> <span class='kw'>true</span><span class='rparen'>)</span>
  <span class='id identifier rubyid_port_writer'>port_writer</span> <span class='op'>=</span> <span class='id identifier rubyid_c'>c</span><span class='period'>.</span><span class='id identifier rubyid_speed'>speed</span><span class='period'>.</span><span class='id identifier rubyid_writer'>writer</span><span class='lparen'>(</span><span class='symbol'>:type</span> <span class='op'>=&gt;</span> <span class='symbol'>:buffer</span><span class='comma'>,</span> <span class='symbol'>:size</span> <span class='op'>=&gt;</span> <span class='int'>10</span><span class='comma'>,</span> <span class='symbol'>:pull</span> <span class='op'>=&gt;</span> <span class='kw'>true</span><span class='rparen'>)</span>
</code></pre>

<p>See Orocos::Port#validate_policy for an in-depth explanation of possible values.</p>

<p>Finally, the task&#39;s methods can be used in this way:</p>

<pre class="code ruby"><code class="ruby">  <span class='id identifier rubyid_m'>m</span> <span class='op'>=</span> <span class='id identifier rubyid_c'>c</span><span class='period'>.</span><span class='id identifier rubyid_rtt_method'>rtt_method</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>watch</span><span class='tstring_end'>&#39;</span></span><span class='rparen'>)</span>
  <span class='id identifier rubyid_ret'>ret</span> <span class='op'>=</span> <span class='id identifier rubyid_m'>m</span><span class='period'>.</span><span class='id identifier rubyid_call'>call</span><span class='lparen'>(</span><span class='id identifier rubyid_arg1'>arg1</span><span class='comma'>,</span> <span class='id identifier rubyid_arg2'>arg2</span><span class='rparen'>)</span>
</code></pre>

<p>and commands are used:</p>

<pre class="code ruby"><code class="ruby">  <span class='id identifier rubyid_m'>m</span> <span class='op'>=</span> <span class='id identifier rubyid_c'>c</span><span class='period'>.</span><span class='id identifier rubyid_rtt_command'>rtt_command</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>watch</span><span class='tstring_end'>&#39;</span></span><span class='rparen'>)</span>
  <span class='id identifier rubyid_handle'>handle</span> <span class='op'>=</span> <span class='id identifier rubyid_m'>m</span><span class='period'>.</span><span class='id identifier rubyid_call'>call</span><span class='lparen'>(</span><span class='id identifier rubyid_arg1'>arg1</span><span class='comma'>,</span> <span class='id identifier rubyid_arg2'>arg2</span><span class='rparen'>)</span>
  <span class='comment'># Check if the command is finished
</span></code></pre>

<p>Both calls store the arguments on the remote component, so if the same method is
to be called repeatedly, use #recall:</p>

<pre class="code ruby"><code class="ruby">  <span class='id identifier rubyid_m'>m</span> <span class='op'>=</span> <span class='id identifier rubyid_c'>c</span><span class='period'>.</span><span class='id identifier rubyid_rtt_method'>rtt_method</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>watch</span><span class='tstring_end'>&#39;</span></span><span class='rparen'>)</span>
  <span class='id identifier rubyid_ret'>ret</span> <span class='op'>=</span> <span class='id identifier rubyid_m'>m</span><span class='period'>.</span><span class='id identifier rubyid_call'>call</span><span class='lparen'>(</span><span class='id identifier rubyid_arg1'>arg1</span><span class='comma'>,</span> <span class='id identifier rubyid_arg2'>arg2</span><span class='rparen'>)</span>
  <span class='id identifier rubyid_ret2'>ret2</span> <span class='op'>=</span> <span class='id identifier rubyid_m'>m</span><span class='period'>.</span><span class='id identifier rubyid_recall'>recall</span>
</code></pre>

<p>Orocos::TaskContext#rtt_method returns an Orocos::RTTMethod object while
Orocos::TaskContext#rtt_command returns an Orocos::Command one.</p>

<h2>Connecting task contexts together</h2>

<p>It is possible to connect ports using orocos.rb. Simply do:</p>

<pre class="code ruby"><code class="ruby">  <span class='comment'># Get the InputPort and OutputPort instances# Get the InputPort and OutputPort
</span>  <span class='id identifier rubyid_instances'>instances</span><span class='comment'># Get the InputPort and OutputPort instances
</span>  <span class='id identifier rubyid_input_port'>input_port</span>  <span class='op'>=</span> <span class='id identifier rubyid_c'>c</span><span class='period'>.</span><span class='id identifier rubyid_input'>input</span>
  <span class='id identifier rubyid_output_port'>output_port</span> <span class='op'>=</span> <span class='id identifier rubyid_c'>c</span><span class='period'>.</span><span class='id identifier rubyid_output'>output</span>
  <span class='id identifier rubyid_output_port'>output_port</span><span class='period'>.</span><span class='id identifier rubyid_connect_to'>connect_to</span><span class='lparen'>(</span><span class='id identifier rubyid_input_port'>input_port</span><span class='comma'>,</span> <span class='id identifier rubyid_policy'>policy</span><span class='rparen'>)</span>
</code></pre>

<p>+policy+ is the connection. It is a hash whose arguments are the policy
parameters. See Orocos::Port#validate_policy for an in-depth explanation of
possible values.</p>

<h2>Testing</h2>

<p>To run the test suite:</p>

<pre class="code ruby"><code class="ruby">$&gt; rake test
</code></pre>

<p>To run tests individually on a per file basis:</p>

<pre class="code ruby"><code class="ruby">$&gt; ruby -I . ./test/test_orocos.rb
</code></pre>

<p>To run tests individually on a per name basis using a matching regexp:</p>

<pre class="code ruby"><code class="ruby">$&gt; ruby -I . ./test/test_port.rb -n /creates/ --verbose
use of MQueue disabled. Set USE_MQUEUE=1 to enable
use of ROS disabled. Set USE_ROS=1 to enable
Run options: -n /creates/ --verbose --seed 65206

# Running:

Orocos::Port::handle_mq_transport#test_0001_creates an updated policy = 0.07 s = .

Finished in 0.068654s, 14.5659 runs/s, 14.5659 assertions/s.

1 runs, 1 assertions, 0 failures, 0 errors, 0 skips

</code></pre>
</div></div>

      <div id="footer">
  Generated on Wed Apr 10 22:10:20 2019 by
  <a href="http://yardoc.org" title="Yay! A Ruby Documentation Tool" target="_parent">yard</a>
  0.9.19 (ruby-2.5.1).
</div>

    </div>
  </body>
</html>