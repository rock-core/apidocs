<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>base: base::samples::DepthMap Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">base
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacebase.html">base</a></li><li class="navelem"><a class="el" href="namespacebase_1_1samples.html">samples</a></li><li class="navelem"><a class="el" href="structbase_1_1samples_1_1DepthMap.html">DepthMap</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="structbase_1_1samples_1_1DepthMap-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">base::samples::DepthMap Struct Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="DepthMap_8hpp_source.html">DepthMap.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a03aeeee9c5cef83ee8a54718e4f12d42"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbase_1_1samples_1_1DepthMap.html#a03aeeee9c5cef83ee8a54718e4f12d42">DEPTH_MEASUREMENT_STATE</a> { <a class="el" href="structbase_1_1samples_1_1DepthMap.html#a03aeeee9c5cef83ee8a54718e4f12d42a3d5fe3c6fbdfe421f3049d0c7c74937b">VALID_MEASUREMENT</a> = 0, 
<a class="el" href="structbase_1_1samples_1_1DepthMap.html#a03aeeee9c5cef83ee8a54718e4f12d42a54ff9e12cce3fb4700ac40ef4a19c275">TOO_FAR</a> = 1, 
<a class="el" href="structbase_1_1samples_1_1DepthMap.html#a03aeeee9c5cef83ee8a54718e4f12d42ad1887ba14d69bfc8676c4b3dc23bdd9b">TOO_NEAR</a> = 2, 
<a class="el" href="structbase_1_1samples_1_1DepthMap.html#a03aeeee9c5cef83ee8a54718e4f12d42a22bb65ec9ddde134daf3f0638aaf4e0d">MEASUREMENT_ERROR</a> = 3
 }</td></tr>
<tr class="separator:a03aeeee9c5cef83ee8a54718e4f12d42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c9bd053c2979b78862592d658cc58a7"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbase_1_1samples_1_1DepthMap.html#a9c9bd053c2979b78862592d658cc58a7">PROJECTION_TYPE</a> { <a class="el" href="structbase_1_1samples_1_1DepthMap.html#a9c9bd053c2979b78862592d658cc58a7a7d9251430cab98542f17471f717d96d0">POLAR</a>, 
<a class="el" href="structbase_1_1samples_1_1DepthMap.html#a9c9bd053c2979b78862592d658cc58a7ab257d0e0b1ffa8de4750e3b021041993">PLANAR</a>
 }</td></tr>
<tr class="separator:a9c9bd053c2979b78862592d658cc58a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15478e50df8ff85094de904f26362c01"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbase_1_1samples_1_1DepthMap.html#a15478e50df8ff85094de904f26362c01">UNIT_AXIS</a> { <a class="el" href="structbase_1_1samples_1_1DepthMap.html#a15478e50df8ff85094de904f26362c01a524b9188b81cf66b59c7a00ca4c64d1e">UNIT_X</a> = 0, 
<a class="el" href="structbase_1_1samples_1_1DepthMap.html#a15478e50df8ff85094de904f26362c01a0798afaa07731111b13473a134d9b70b">UNIT_Y</a> = 1, 
<a class="el" href="structbase_1_1samples_1_1DepthMap.html#a15478e50df8ff85094de904f26362c01a827a5a6e67dce24815a01f2c56a2e4d3">UNIT_Z</a> = 2
 }</td></tr>
<tr class="separator:a15478e50df8ff85094de904f26362c01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c47293285ef9349f1ce44623ede4206"><td class="memItemLeft" align="right" valign="top">typedef float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbase_1_1samples_1_1DepthMap.html#a6c47293285ef9349f1ce44623ede4206">scalar</a></td></tr>
<tr class="separator:a6c47293285ef9349f1ce44623ede4206"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2746151269e3354cb8ba446d7362b055"><td class="memItemLeft" align="right" valign="top">typedef boost::uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbase_1_1samples_1_1DepthMap.html#a2746151269e3354cb8ba446d7362b055">uint32_t</a></td></tr>
<tr class="separator:a2746151269e3354cb8ba446d7362b055"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38c7e5d4805f14509b02b2a0147b5f27"><td class="memItemLeft" align="right" valign="top">typedef Eigen::Matrix&lt; <a class="el" href="structbase_1_1samples_1_1DepthMap.html#a6c47293285ef9349f1ce44623ede4206">scalar</a>, Eigen::Dynamic, Eigen::Dynamic, Eigen::DontAlign|Eigen::RowMajor &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbase_1_1samples_1_1DepthMap.html#a38c7e5d4805f14509b02b2a0147b5f27">DepthMatrix</a></td></tr>
<tr class="separator:a38c7e5d4805f14509b02b2a0147b5f27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a301da6d2fcb4bf377fe12d300914ae5c"><td class="memItemLeft" align="right" valign="top">typedef const Eigen::Matrix&lt; <a class="el" href="structbase_1_1samples_1_1DepthMap.html#a6c47293285ef9349f1ce44623ede4206">scalar</a>, Eigen::Dynamic, Eigen::Dynamic, Eigen::DontAlign|Eigen::RowMajor &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbase_1_1samples_1_1DepthMap.html#a301da6d2fcb4bf377fe12d300914ae5c">DepthMatrixConst</a></td></tr>
<tr class="separator:a301da6d2fcb4bf377fe12d300914ae5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2248b9081f5b0f5606e7cfaf61677495"><td class="memItemLeft" align="right" valign="top">typedef Eigen::Map&lt; <a class="el" href="structbase_1_1samples_1_1DepthMap.html#a38c7e5d4805f14509b02b2a0147b5f27">DepthMatrix</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbase_1_1samples_1_1DepthMap.html#a2248b9081f5b0f5606e7cfaf61677495">DepthMatrixMap</a></td></tr>
<tr class="separator:a2248b9081f5b0f5606e7cfaf61677495"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d41b6a2be9a6c5efec6b49d2c1c0c7e"><td class="memItemLeft" align="right" valign="top">typedef const Eigen::Map&lt; <a class="el" href="structbase_1_1samples_1_1DepthMap.html#a301da6d2fcb4bf377fe12d300914ae5c">DepthMatrixConst</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbase_1_1samples_1_1DepthMap.html#a8d41b6a2be9a6c5efec6b49d2c1c0c7e">DepthMatrixMapConst</a></td></tr>
<tr class="separator:a8d41b6a2be9a6c5efec6b49d2c1c0c7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:abc3c05b9eb2f9ecfc884858d6c66ff73"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbase_1_1samples_1_1DepthMap.html#abc3c05b9eb2f9ecfc884858d6c66ff73">DepthMap</a> ()</td></tr>
<tr class="separator:abc3c05b9eb2f9ecfc884858d6c66ff73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a849ba98c60a33d7c7544f64859bc0fce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbase_1_1samples_1_1DepthMap.html#a849ba98c60a33d7c7544f64859bc0fce">reset</a> ()</td></tr>
<tr class="separator:a849ba98c60a33d7c7544f64859bc0fce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4070635ffb971a025c0b4537f63361be"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structbase_1_1samples_1_1DepthMap.html#a2248b9081f5b0f5606e7cfaf61677495">DepthMatrixMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbase_1_1samples_1_1DepthMap.html#a4070635ffb971a025c0b4537f63361be">getDistanceMatrixMap</a> ()</td></tr>
<tr class="separator:a4070635ffb971a025c0b4537f63361be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5cb92784e217d387f0441a1dae220aa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structbase_1_1samples_1_1DepthMap.html#a8d41b6a2be9a6c5efec6b49d2c1c0c7e">DepthMatrixMapConst</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbase_1_1samples_1_1DepthMap.html#af5cb92784e217d387f0441a1dae220aa">getDistanceMatrixMapConst</a> () const</td></tr>
<tr class="separator:af5cb92784e217d387f0441a1dae220aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9832029bc30bafe80948bbe5fc30e23"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structbase_1_1samples_1_1DepthMap.html#a03aeeee9c5cef83ee8a54718e4f12d42">DEPTH_MEASUREMENT_STATE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbase_1_1samples_1_1DepthMap.html#ae9832029bc30bafe80948bbe5fc30e23">getIndexState</a> (size_t index) const</td></tr>
<tr class="separator:ae9832029bc30bafe80948bbe5fc30e23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91731732226bd6ae29ae75767fca67da"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structbase_1_1samples_1_1DepthMap.html#a03aeeee9c5cef83ee8a54718e4f12d42">DEPTH_MEASUREMENT_STATE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbase_1_1samples_1_1DepthMap.html#a91731732226bd6ae29ae75767fca67da">getMeasurementState</a> (<a class="el" href="structbase_1_1samples_1_1DepthMap.html#a2746151269e3354cb8ba446d7362b055">uint32_t</a> v_index, <a class="el" href="structbase_1_1samples_1_1DepthMap.html#a2746151269e3354cb8ba446d7362b055">uint32_t</a> h_index) const</td></tr>
<tr class="separator:a91731732226bd6ae29ae75767fca67da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08a65d7f4af11711b61bc68e972236ae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structbase_1_1samples_1_1DepthMap.html#a03aeeee9c5cef83ee8a54718e4f12d42">DEPTH_MEASUREMENT_STATE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbase_1_1samples_1_1DepthMap.html#a08a65d7f4af11711b61bc68e972236ae">getMeasurementState</a> (<a class="el" href="structbase_1_1samples_1_1DepthMap.html#a6c47293285ef9349f1ce44623ede4206">scalar</a> distance) const</td></tr>
<tr class="separator:a08a65d7f4af11711b61bc68e972236ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46734d568d836ee80e7c92dc58fb48f8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbase_1_1samples_1_1DepthMap.html#a46734d568d836ee80e7c92dc58fb48f8">isIndexValid</a> (size_t index) const</td></tr>
<tr class="separator:a46734d568d836ee80e7c92dc58fb48f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63f923bf8aa2470d39efb86b3bbf5907"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbase_1_1samples_1_1DepthMap.html#a63f923bf8aa2470d39efb86b3bbf5907">isMeasurementValid</a> (<a class="el" href="structbase_1_1samples_1_1DepthMap.html#a2746151269e3354cb8ba446d7362b055">uint32_t</a> v_index, <a class="el" href="structbase_1_1samples_1_1DepthMap.html#a2746151269e3354cb8ba446d7362b055">uint32_t</a> h_index) const</td></tr>
<tr class="separator:a63f923bf8aa2470d39efb86b3bbf5907"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6cc49914b9a6a86d4b9f2f5c85bb5e3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbase_1_1samples_1_1DepthMap.html#af6cc49914b9a6a86d4b9f2f5c85bb5e3">isMeasurementValid</a> (<a class="el" href="structbase_1_1samples_1_1DepthMap.html#a6c47293285ef9349f1ce44623ede4206">scalar</a> distance) const</td></tr>
<tr class="separator:af6cc49914b9a6a86d4b9f2f5c85bb5e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a726ec2161b6cfa48016a4ebfdd519e4f"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbase_1_1samples_1_1DepthMap.html#a726ec2161b6cfa48016a4ebfdd519e4f">getIndex</a> (<a class="el" href="structbase_1_1samples_1_1DepthMap.html#a2746151269e3354cb8ba446d7362b055">uint32_t</a> v_index, <a class="el" href="structbase_1_1samples_1_1DepthMap.html#a2746151269e3354cb8ba446d7362b055">uint32_t</a> h_index) const</td></tr>
<tr class="separator:a726ec2161b6cfa48016a4ebfdd519e4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafc3345bfd3e776d24a961097417ab59"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aafc3345bfd3e776d24a961097417ab59"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structbase_1_1samples_1_1DepthMap.html#aafc3345bfd3e776d24a961097417ab59">convertDepthMapToPointCloud</a> (std::vector&lt; T &gt; &amp;point_cloud, bool use_lut=false, bool skip_invalid_measurements=true) const</td></tr>
<tr class="separator:aafc3345bfd3e776d24a961097417ab59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac23b61b196e1b4f368de39cc25f7872f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac23b61b196e1b4f368de39cc25f7872f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structbase_1_1samples_1_1DepthMap.html#ac23b61b196e1b4f368de39cc25f7872f">convertDepthMapToPointCloud</a> (std::vector&lt; T &gt; &amp;point_cloud, const Eigen::Transform&lt; typename T::Scalar, 3, Eigen::Affine &gt; &amp;transformation, bool use_lut=false, bool skip_invalid_measurements=true) const</td></tr>
<tr class="separator:ac23b61b196e1b4f368de39cc25f7872f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31a7c6ef3ea72e79d41158c3a2fb1d13"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a31a7c6ef3ea72e79d41158c3a2fb1d13"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structbase_1_1samples_1_1DepthMap.html#a31a7c6ef3ea72e79d41158c3a2fb1d13">convertDepthMapToPointCloud</a> (std::vector&lt; T &gt; &amp;point_cloud, const Eigen::Transform&lt; typename T::Scalar, 3, Eigen::Affine &gt; &amp;first_transformation, const Eigen::Transform&lt; typename T::Scalar, 3, Eigen::Affine &gt; &amp;last_transformation, bool use_lut=false, bool skip_invalid_measurements=true, bool apply_transforms_vertically=true) const</td></tr>
<tr class="separator:a31a7c6ef3ea72e79d41158c3a2fb1d13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9b71f9f58315259296fb617c0db4f0d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad9b71f9f58315259296fb617c0db4f0d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structbase_1_1samples_1_1DepthMap.html#ad9b71f9f58315259296fb617c0db4f0d">convertDepthMapToPointCloud</a> (std::vector&lt; T &gt; &amp;point_cloud, const std::vector&lt; Eigen::Transform&lt; typename T::Scalar, 3, Eigen::Affine &gt;, Eigen::aligned_allocator&lt; Eigen::Transform&lt; typename T::Scalar, 3, Eigen::Affine &gt; &gt; &gt; &amp;transformations, bool use_lut=false, bool skip_invalid_measurements=true, bool apply_transforms_vertically=true) const</td></tr>
<tr class="separator:ad9b71f9f58315259296fb617c0db4f0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:ae47e3bce314d63cc590183ddf3f1565e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structbase_1_1Time.html">base::Time</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbase_1_1samples_1_1DepthMap.html#ae47e3bce314d63cc590183ddf3f1565e">time</a></td></tr>
<tr class="separator:ae47e3bce314d63cc590183ddf3f1565e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a977af67b71f8d91ad59e2cb3dc38d34b"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structbase_1_1Time.html">base::Time</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbase_1_1samples_1_1DepthMap.html#a977af67b71f8d91ad59e2cb3dc38d34b">timestamps</a></td></tr>
<tr class="separator:a977af67b71f8d91ad59e2cb3dc38d34b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab92e02e93419204920914efe882be85d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structbase_1_1samples_1_1DepthMap.html#a9c9bd053c2979b78862592d658cc58a7">PROJECTION_TYPE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbase_1_1samples_1_1DepthMap.html#ab92e02e93419204920914efe882be85d">vertical_projection</a></td></tr>
<tr class="separator:ab92e02e93419204920914efe882be85d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d83367c77c4b6214dc18c3a31dda244"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structbase_1_1samples_1_1DepthMap.html#a9c9bd053c2979b78862592d658cc58a7">PROJECTION_TYPE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbase_1_1samples_1_1DepthMap.html#a4d83367c77c4b6214dc18c3a31dda244">horizontal_projection</a></td></tr>
<tr class="separator:a4d83367c77c4b6214dc18c3a31dda244"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5436e6c2ae542141f15dab930e5d1db1"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbase_1_1samples_1_1DepthMap.html#a5436e6c2ae542141f15dab930e5d1db1">vertical_interval</a></td></tr>
<tr class="separator:a5436e6c2ae542141f15dab930e5d1db1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93e589770b00c598231bb629cb02f029"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbase_1_1samples_1_1DepthMap.html#a93e589770b00c598231bb629cb02f029">horizontal_interval</a></td></tr>
<tr class="separator:a93e589770b00c598231bb629cb02f029"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37b72bc33d0c0dda95c6d486237b9f78"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structbase_1_1samples_1_1DepthMap.html#a2746151269e3354cb8ba446d7362b055">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbase_1_1samples_1_1DepthMap.html#a37b72bc33d0c0dda95c6d486237b9f78">vertical_size</a></td></tr>
<tr class="separator:a37b72bc33d0c0dda95c6d486237b9f78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a6b0e293816dfc2ebaa4a29668b74bc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structbase_1_1samples_1_1DepthMap.html#a2746151269e3354cb8ba446d7362b055">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbase_1_1samples_1_1DepthMap.html#a2a6b0e293816dfc2ebaa4a29668b74bc">horizontal_size</a></td></tr>
<tr class="separator:a2a6b0e293816dfc2ebaa4a29668b74bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16d7fd650971442a8e092cfaab3da0fb"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structbase_1_1samples_1_1DepthMap.html#a6c47293285ef9349f1ce44623ede4206">scalar</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbase_1_1samples_1_1DepthMap.html#a16d7fd650971442a8e092cfaab3da0fb">distances</a></td></tr>
<tr class="separator:a16d7fd650971442a8e092cfaab3da0fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa60ca1cbf9e52b1d5c4861996c6c7073"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structbase_1_1samples_1_1DepthMap.html#a6c47293285ef9349f1ce44623ede4206">scalar</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbase_1_1samples_1_1DepthMap.html#aa60ca1cbf9e52b1d5c4861996c6c7073">remissions</a></td></tr>
<tr class="separator:aa60ca1cbf9e52b1d5c4861996c6c7073"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:af4cfdde8adea174979763109b30d93e4"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af4cfdde8adea174979763109b30d93e4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structbase_1_1samples_1_1DepthMap.html#af4cfdde8adea174979763109b30d93e4">convertSingleRow</a> (std::vector&lt; T &gt; &amp;point_cloud, unsigned int row, const Eigen::Transform&lt; typename T::Scalar, 3, Eigen::Affine &gt; &amp;row2column, const std::vector&lt; Eigen::Transform&lt; typename T::Scalar, 3, Eigen::Affine &gt;, Eigen::aligned_allocator&lt; Eigen::Transform&lt; typename T::Scalar, 3, Eigen::Affine &gt; &gt; &gt; &amp;columns2pointcloud, const Eigen::Transform&lt; typename T::Scalar, 3, Eigen::Affine &gt; &amp;pointcloud2world, bool skip_invalid_measurements) const</td></tr>
<tr class="separator:af4cfdde8adea174979763109b30d93e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fa21f0167d697cd5cab18e00e57343e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6fa21f0167d697cd5cab18e00e57343e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structbase_1_1samples_1_1DepthMap.html#a6fa21f0167d697cd5cab18e00e57343e">computeLocalTransformations</a> (std::vector&lt; Eigen::Transform&lt; T, 3, Eigen::Affine &gt;, Eigen::aligned_allocator&lt; Eigen::Transform&lt; T, 3, Eigen::Affine &gt; &gt; &gt; &amp;rows2column, std::vector&lt; Eigen::Transform&lt; T, 3, Eigen::Affine &gt;, Eigen::aligned_allocator&lt; Eigen::Transform&lt; T, 3, Eigen::Affine &gt; &gt; &gt; &amp;columns2pointcloud, bool use_lut=false) const</td></tr>
<tr class="separator:a6fa21f0167d697cd5cab18e00e57343e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d6668d7c92eb45374a067f70ed707b3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7d6668d7c92eb45374a067f70ed707b3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structbase_1_1samples_1_1DepthMap.html#a7d6668d7c92eb45374a067f70ed707b3">computeRotations</a> (std::vector&lt; Eigen::Transform&lt; T, 3, Eigen::Affine &gt;, Eigen::aligned_allocator&lt; Eigen::Transform&lt; T, 3, Eigen::Affine &gt; &gt; &gt; &amp;rotations, const std::vector&lt; <a class="el" href="classbase_1_1Angle.html">base::Angle</a> &gt; &amp;angles, <a class="el" href="structbase_1_1samples_1_1DepthMap.html#a15478e50df8ff85094de904f26362c01">UNIT_AXIS</a> axis, bool use_lut=false) const</td></tr>
<tr class="separator:a7d6668d7c92eb45374a067f70ed707b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a235933b0f74821905ee4ec5505ab6ba6"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbase_1_1samples_1_1DepthMap.html#a235933b0f74821905ee4ec5505ab6ba6">computeResolution</a> (const std::vector&lt; double &gt; &amp;interval, <a class="el" href="structbase_1_1samples_1_1DepthMap.html#a2746151269e3354cb8ba446d7362b055">uint32_t</a> elements, <a class="el" href="structbase_1_1samples_1_1DepthMap.html#a9c9bd053c2979b78862592d658cc58a7">PROJECTION_TYPE</a> projection) const</td></tr>
<tr class="separator:a235933b0f74821905ee4ec5505ab6ba6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2877f7d97e63729801346aad37bde6c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbase_1_1samples_1_1DepthMap.html#ac2877f7d97e63729801346aad37bde6c">checkSizeConfig</a> () const</td></tr>
<tr class="separator:ac2877f7d97e63729801346aad37bde6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The <a class="el" href="structbase_1_1samples_1_1DepthMap.html">DepthMap</a> type provides distance and optional remission values in 3D. The information is stored in a vector in a row major form, to simplify the usage as a distance image. One row is a set of horizontal arranged single measurements with an identical vertical position or angle. The distance and remission fields can therefore be seen as a image plane or a matrix. The horizontal and vertical intervals can be in polar or in planar form. In polar they are interpreted as angles and in planar form they are interpreted as coordinates on a depth-image plane. Horizontal intervals are always defined from left to right and vertical intervals are always defined top down. Each field of intervals can either have two entries, which define a range of regular arranged measurements, or one entry per measurement to represent the irregular case. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a38c7e5d4805f14509b02b2a0147b5f27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38c7e5d4805f14509b02b2a0147b5f27">&#9670;&nbsp;</a></span>DepthMatrix</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef Eigen::Matrix&lt;<a class="el" href="structbase_1_1samples_1_1DepthMap.html#a6c47293285ef9349f1ce44623ede4206">scalar</a>, Eigen::Dynamic, Eigen::Dynamic, Eigen::DontAlign | Eigen::RowMajor&gt; <a class="el" href="structbase_1_1samples_1_1DepthMap.html#a38c7e5d4805f14509b02b2a0147b5f27">base::samples::DepthMap::DepthMatrix</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a301da6d2fcb4bf377fe12d300914ae5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a301da6d2fcb4bf377fe12d300914ae5c">&#9670;&nbsp;</a></span>DepthMatrixConst</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef const Eigen::Matrix&lt;<a class="el" href="structbase_1_1samples_1_1DepthMap.html#a6c47293285ef9349f1ce44623ede4206">scalar</a>, Eigen::Dynamic, Eigen::Dynamic, Eigen::DontAlign | Eigen::RowMajor&gt; <a class="el" href="structbase_1_1samples_1_1DepthMap.html#a301da6d2fcb4bf377fe12d300914ae5c">base::samples::DepthMap::DepthMatrixConst</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2248b9081f5b0f5606e7cfaf61677495"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2248b9081f5b0f5606e7cfaf61677495">&#9670;&nbsp;</a></span>DepthMatrixMap</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef Eigen::Map&lt; <a class="el" href="structbase_1_1samples_1_1DepthMap.html#a38c7e5d4805f14509b02b2a0147b5f27">DepthMatrix</a> &gt; <a class="el" href="structbase_1_1samples_1_1DepthMap.html#a2248b9081f5b0f5606e7cfaf61677495">base::samples::DepthMap::DepthMatrixMap</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8d41b6a2be9a6c5efec6b49d2c1c0c7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d41b6a2be9a6c5efec6b49d2c1c0c7e">&#9670;&nbsp;</a></span>DepthMatrixMapConst</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef const Eigen::Map&lt; <a class="el" href="structbase_1_1samples_1_1DepthMap.html#a301da6d2fcb4bf377fe12d300914ae5c">DepthMatrixConst</a> &gt; <a class="el" href="structbase_1_1samples_1_1DepthMap.html#a8d41b6a2be9a6c5efec6b49d2c1c0c7e">base::samples::DepthMap::DepthMatrixMapConst</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6c47293285ef9349f1ce44623ede4206"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c47293285ef9349f1ce44623ede4206">&#9670;&nbsp;</a></span>scalar</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef float <a class="el" href="structbase_1_1samples_1_1DepthMap.html#a6c47293285ef9349f1ce44623ede4206">base::samples::DepthMap::scalar</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2746151269e3354cb8ba446d7362b055"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2746151269e3354cb8ba446d7362b055">&#9670;&nbsp;</a></span>uint32_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef boost::uint32_t <a class="el" href="structbase_1_1samples_1_1DepthMap.html#a2746151269e3354cb8ba446d7362b055">base::samples::DepthMap::uint32_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a03aeeee9c5cef83ee8a54718e4f12d42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03aeeee9c5cef83ee8a54718e4f12d42">&#9670;&nbsp;</a></span>DEPTH_MEASUREMENT_STATE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="structbase_1_1samples_1_1DepthMap.html#a03aeeee9c5cef83ee8a54718e4f12d42">base::samples::DepthMap::DEPTH_MEASUREMENT_STATE</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a03aeeee9c5cef83ee8a54718e4f12d42a3d5fe3c6fbdfe421f3049d0c7c74937b"></a>VALID_MEASUREMENT&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a03aeeee9c5cef83ee8a54718e4f12d42a54ff9e12cce3fb4700ac40ef4a19c275"></a>TOO_FAR&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a03aeeee9c5cef83ee8a54718e4f12d42ad1887ba14d69bfc8676c4b3dc23bdd9b"></a>TOO_NEAR&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a03aeeee9c5cef83ee8a54718e4f12d42a22bb65ec9ddde134daf3f0638aaf4e0d"></a>MEASUREMENT_ERROR&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a9c9bd053c2979b78862592d658cc58a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c9bd053c2979b78862592d658cc58a7">&#9670;&nbsp;</a></span>PROJECTION_TYPE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="structbase_1_1samples_1_1DepthMap.html#a9c9bd053c2979b78862592d658cc58a7">base::samples::DepthMap::PROJECTION_TYPE</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a9c9bd053c2979b78862592d658cc58a7a7d9251430cab98542f17471f717d96d0"></a>POLAR&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a9c9bd053c2979b78862592d658cc58a7ab257d0e0b1ffa8de4750e3b021041993"></a>PLANAR&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a15478e50df8ff85094de904f26362c01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15478e50df8ff85094de904f26362c01">&#9670;&nbsp;</a></span>UNIT_AXIS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="structbase_1_1samples_1_1DepthMap.html#a15478e50df8ff85094de904f26362c01">base::samples::DepthMap::UNIT_AXIS</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a15478e50df8ff85094de904f26362c01a524b9188b81cf66b59c7a00ca4c64d1e"></a>UNIT_X&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a15478e50df8ff85094de904f26362c01a0798afaa07731111b13473a134d9b70b"></a>UNIT_Y&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a15478e50df8ff85094de904f26362c01a827a5a6e67dce24815a01f2c56a2e4d3"></a>UNIT_Z&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="abc3c05b9eb2f9ecfc884858d6c66ff73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc3c05b9eb2f9ecfc884858d6c66ff73">&#9670;&nbsp;</a></span>DepthMap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">base::samples::DepthMap::DepthMap </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ac2877f7d97e63729801346aad37bde6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2877f7d97e63729801346aad37bde6c">&#9670;&nbsp;</a></span>checkSizeConfig()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool base::samples::DepthMap::checkSizeConfig </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Checks if the vertical and horizontal sizes match the size of distance vector. </p>

</div>
</div>
<a id="a6fa21f0167d697cd5cab18e00e57343e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fa21f0167d697cd5cab18e00e57343e">&#9670;&nbsp;</a></span>computeLocalTransformations()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void base::samples::DepthMap::computeLocalTransformations </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; Eigen::Transform&lt; T, 3, Eigen::Affine &gt;, Eigen::aligned_allocator&lt; Eigen::Transform&lt; T, 3, Eigen::Affine &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>rows2column</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; Eigen::Transform&lt; T, 3, Eigen::Affine &gt;, Eigen::aligned_allocator&lt; Eigen::Transform&lt; T, 3, Eigen::Affine &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>columns2pointcloud</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_lut</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Helper method to compute the local rows2column and columns2pointcloud transformations. </p>

</div>
</div>
<a id="a235933b0f74821905ee4ec5505ab6ba6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a235933b0f74821905ee4ec5505ab6ba6">&#9670;&nbsp;</a></span>computeResolution()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double base::samples::DepthMap::computeResolution </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>interval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbase_1_1samples_1_1DepthMap.html#a2746151269e3354cb8ba446d7362b055">uint32_t</a>&#160;</td>
          <td class="paramname"><em>elements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbase_1_1samples_1_1DepthMap.html#a9c9bd053c2979b78862592d658cc58a7">PROJECTION_TYPE</a>&#160;</td>
          <td class="paramname"><em>projection</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Computes the resolution in a given interval. </p>

</div>
</div>
<a id="a7d6668d7c92eb45374a067f70ed707b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d6668d7c92eb45374a067f70ed707b3">&#9670;&nbsp;</a></span>computeRotations()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void base::samples::DepthMap::computeRotations </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; Eigen::Transform&lt; T, 3, Eigen::Affine &gt;, Eigen::aligned_allocator&lt; Eigen::Transform&lt; T, 3, Eigen::Affine &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>rotations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbase_1_1Angle.html">base::Angle</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>angles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbase_1_1samples_1_1DepthMap.html#a15478e50df8ff85094de904f26362c01">UNIT_AXIS</a>&#160;</td>
          <td class="paramname"><em>axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_lut</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Helper method to compute the rotations around an unit axis. </p>

</div>
</div>
<a id="aafc3345bfd3e776d24a961097417ab59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafc3345bfd3e776d24a961097417ab59">&#9670;&nbsp;</a></span>convertDepthMapToPointCloud() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void base::samples::DepthMap::convertDepthMapToPointCloud </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>point_cloud</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_lut</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>skip_invalid_measurements</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Converts the depth map to a pointcloud in the coordinate system of the sensor (x-axis = forward, y-axis = to the left, z-axis = upwards). If the resulting pointcloud should be associated with the remission values the invalid measurements should not be skipped. The template point type must be derived from a 3D eigen vector.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">point_cloud</td><td>returned pointcloud </td></tr>
    <tr><td class="paramname">use_lut</td><td>true, if lookup table for single unit axis rotations shall be used </td></tr>
    <tr><td class="paramname">skip_invalid_measurements</td><td>true, if invalid measurements should be skipped </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac23b61b196e1b4f368de39cc25f7872f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac23b61b196e1b4f368de39cc25f7872f">&#9670;&nbsp;</a></span>convertDepthMapToPointCloud() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void base::samples::DepthMap::convertDepthMapToPointCloud </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>point_cloud</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Transform&lt; typename T::Scalar, 3, Eigen::Affine &gt; &amp;&#160;</td>
          <td class="paramname"><em>transformation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_lut</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>skip_invalid_measurements</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Converts the depth map to a pointcloud according to the given transformation matrix. If the transformation matrix is set to identity the depth map is converted into the coordinate system of the sensor (x-axis = forward, y-axis = to the left, z-axis = upwards). If the resulting pointcloud should be associated with the remission values the invalid measurements should not be skipped. The template point type must be derived from a 3D eigen vector.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">point_cloud</td><td>returned pointcloud </td></tr>
    <tr><td class="paramname">transformation</td><td>all points will be transformed using this transformation </td></tr>
    <tr><td class="paramname">use_lut</td><td>true, if lookup table for single unit axis rotations shall be used </td></tr>
    <tr><td class="paramname">skip_invalid_measurements</td><td>true, if invalid measurements should be skipped </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a31a7c6ef3ea72e79d41158c3a2fb1d13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31a7c6ef3ea72e79d41158c3a2fb1d13">&#9670;&nbsp;</a></span>convertDepthMapToPointCloud() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void base::samples::DepthMap::convertDepthMapToPointCloud </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>point_cloud</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Transform&lt; typename T::Scalar, 3, Eigen::Affine &gt; &amp;&#160;</td>
          <td class="paramname"><em>first_transformation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Transform&lt; typename T::Scalar, 3, Eigen::Affine &gt; &amp;&#160;</td>
          <td class="paramname"><em>last_transformation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_lut</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>skip_invalid_measurements</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>apply_transforms_vertically</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Converts the depth map to a pointcloud according to the given transformation matrices. On basis of the first and last transformation the transformations will be interpolated and applied row-wise if the parameter apply_transforms_vertically is set to true, otherwise they will be interpolated and applied col-wise.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">point_cloud</td><td>returned pointcloud </td></tr>
    <tr><td class="paramname">first_transformation</td><td>transformation of the first row or column </td></tr>
    <tr><td class="paramname">last_transformation</td><td>translation of the last row or column </td></tr>
    <tr><td class="paramname">use_lut</td><td>true, if lookup table for single unit axis rotations shall be used </td></tr>
    <tr><td class="paramname">skip_invalid_measurements</td><td>true, if invalid measurements should be skipped </td></tr>
    <tr><td class="paramname">apply_transforms_vertically</td><td>true, if transformations should be applied row-wise </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad9b71f9f58315259296fb617c0db4f0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9b71f9f58315259296fb617c0db4f0d">&#9670;&nbsp;</a></span>convertDepthMapToPointCloud() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void base::samples::DepthMap::convertDepthMapToPointCloud </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>point_cloud</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Eigen::Transform&lt; typename T::Scalar, 3, Eigen::Affine &gt;, Eigen::aligned_allocator&lt; Eigen::Transform&lt; typename T::Scalar, 3, Eigen::Affine &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>transformations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_lut</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>skip_invalid_measurements</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>apply_transforms_vertically</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Converts the depth map to a pointcloud according to the given transformation matrices. Each transformation in the given vector will be applied to each row if the parameter apply_transforms_vertically is set to true, otherwise it will be applied col-wise. The transformations vector therefore must have either the same size of the columns or the rows.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">point_cloud</td><td>returned pointcloud </td></tr>
    <tr><td class="paramname">transformations</td><td>vector of transformation matrices </td></tr>
    <tr><td class="paramname">use_lut</td><td>true, if lookup table for single unit axis rotations shall be used </td></tr>
    <tr><td class="paramname">skip_invalid_measurements</td><td>true, if invalid measurements should be skipped </td></tr>
    <tr><td class="paramname">apply_transforms_vertically</td><td>true, if transformations should be applied row-wise </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af4cfdde8adea174979763109b30d93e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4cfdde8adea174979763109b30d93e4">&#9670;&nbsp;</a></span>convertSingleRow()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void base::samples::DepthMap::convertSingleRow </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>point_cloud</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Transform&lt; typename T::Scalar, 3, Eigen::Affine &gt; &amp;&#160;</td>
          <td class="paramname"><em>row2column</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Eigen::Transform&lt; typename T::Scalar, 3, Eigen::Affine &gt;, Eigen::aligned_allocator&lt; Eigen::Transform&lt; typename T::Scalar, 3, Eigen::Affine &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>columns2pointcloud</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Transform&lt; typename T::Scalar, 3, Eigen::Affine &gt; &amp;&#160;</td>
          <td class="paramname"><em>pointcloud2world</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>skip_invalid_measurements</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Helper method which converts a single row to a pointcloud. </p>

</div>
</div>
<a id="a4070635ffb971a025c0b4537f63361be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4070635ffb971a025c0b4537f63361be">&#9670;&nbsp;</a></span>getDistanceMatrixMap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbase_1_1samples_1_1DepthMap.html#a2248b9081f5b0f5606e7cfaf61677495">DepthMap::DepthMatrixMap</a> base::samples::DepthMap::getDistanceMatrixMap </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a mapping to a eigen matrix with dynamic sizes </p>

</div>
</div>
<a id="af5cb92784e217d387f0441a1dae220aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5cb92784e217d387f0441a1dae220aa">&#9670;&nbsp;</a></span>getDistanceMatrixMapConst()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbase_1_1samples_1_1DepthMap.html#a8d41b6a2be9a6c5efec6b49d2c1c0c7e">DepthMap::DepthMatrixMapConst</a> base::samples::DepthMap::getDistanceMatrixMapConst </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a mapping to a const eigen matrix with dynamic sizes </p>

</div>
</div>
<a id="a726ec2161b6cfa48016a4ebfdd519e4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a726ec2161b6cfa48016a4ebfdd519e4f">&#9670;&nbsp;</a></span>getIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t base::samples::DepthMap::getIndex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbase_1_1samples_1_1DepthMap.html#a2746151269e3354cb8ba446d7362b055">DepthMap::uint32_t</a>&#160;</td>
          <td class="paramname"><em>v_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbase_1_1samples_1_1DepthMap.html#a2746151269e3354cb8ba446d7362b055">DepthMap::uint32_t</a>&#160;</td>
          <td class="paramname"><em>h_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes the index in the distance and remission vector of a given vertical and horizontal index. Note that the data is stored in row major form. </p>

</div>
</div>
<a id="ae9832029bc30bafe80948bbe5fc30e23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9832029bc30bafe80948bbe5fc30e23">&#9670;&nbsp;</a></span>getIndexState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbase_1_1samples_1_1DepthMap.html#a03aeeee9c5cef83ee8a54718e4f12d42">DepthMap::DEPTH_MEASUREMENT_STATE</a> base::samples::DepthMap::getIndexState </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the measurement state of a given index.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>of the measurement </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a91731732226bd6ae29ae75767fca67da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91731732226bd6ae29ae75767fca67da">&#9670;&nbsp;</a></span>getMeasurementState() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbase_1_1samples_1_1DepthMap.html#a03aeeee9c5cef83ee8a54718e4f12d42">DepthMap::DEPTH_MEASUREMENT_STATE</a> base::samples::DepthMap::getMeasurementState </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbase_1_1samples_1_1DepthMap.html#a2746151269e3354cb8ba446d7362b055">DepthMap::uint32_t</a>&#160;</td>
          <td class="paramname"><em>v_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbase_1_1samples_1_1DepthMap.html#a2746151269e3354cb8ba446d7362b055">DepthMap::uint32_t</a>&#160;</td>
          <td class="paramname"><em>h_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the measurement state of a given vertical and horizontal index.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v_index</td><td></td></tr>
    <tr><td class="paramname">h_index</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a08a65d7f4af11711b61bc68e972236ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08a65d7f4af11711b61bc68e972236ae">&#9670;&nbsp;</a></span>getMeasurementState() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbase_1_1samples_1_1DepthMap.html#a03aeeee9c5cef83ee8a54718e4f12d42">DepthMap::DEPTH_MEASUREMENT_STATE</a> base::samples::DepthMap::getMeasurementState </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbase_1_1samples_1_1DepthMap.html#a6c47293285ef9349f1ce44623ede4206">DepthMap::scalar</a>&#160;</td>
          <td class="paramname"><em>distance</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the measurement state of a given measurement</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">distance</td><td>measurement </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a46734d568d836ee80e7c92dc58fb48f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46734d568d836ee80e7c92dc58fb48f8">&#9670;&nbsp;</a></span>isIndexValid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool base::samples::DepthMap::isIndexValid </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if the measurement at the given index is valid.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>of the measurement </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a63f923bf8aa2470d39efb86b3bbf5907"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63f923bf8aa2470d39efb86b3bbf5907">&#9670;&nbsp;</a></span>isMeasurementValid() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool base::samples::DepthMap::isMeasurementValid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbase_1_1samples_1_1DepthMap.html#a2746151269e3354cb8ba446d7362b055">DepthMap::uint32_t</a>&#160;</td>
          <td class="paramname"><em>v_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbase_1_1samples_1_1DepthMap.html#a2746151269e3354cb8ba446d7362b055">DepthMap::uint32_t</a>&#160;</td>
          <td class="paramname"><em>h_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if the measurement at the given vertical and horizontal index is valid.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v_index</td><td></td></tr>
    <tr><td class="paramname">h_index</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af6cc49914b9a6a86d4b9f2f5c85bb5e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6cc49914b9a6a86d4b9f2f5c85bb5e3">&#9670;&nbsp;</a></span>isMeasurementValid() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool base::samples::DepthMap::isMeasurementValid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbase_1_1samples_1_1DepthMap.html#a6c47293285ef9349f1ce44623ede4206">DepthMap::scalar</a>&#160;</td>
          <td class="paramname"><em>distance</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if the measurement is valid.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">distance</td><td>measurement </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a849ba98c60a33d7c7544f64859bc0fce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a849ba98c60a33d7c7544f64859bc0fce">&#9670;&nbsp;</a></span>reset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void base::samples::DepthMap::reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reset the sample </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a16d7fd650971442a8e092cfaab3da0fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16d7fd650971442a8e092cfaab3da0fb">&#9670;&nbsp;</a></span>distances</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="structbase_1_1samples_1_1DepthMap.html#a6c47293285ef9349f1ce44623ede4206">scalar</a>&gt; base::samples::DepthMap::distances</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The distance samples. The data is arranged in a row major order to simplify the usage as a distance image. One row is a set of horizontal arranged single measurements. The data for a measurement (vertical_index, horizontal_index) is in distances[(vertical_index * horizontal_size) + horizontal_index]. </p>

</div>
</div>
<a id="a93e589770b00c598231bb629cb02f029"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93e589770b00c598231bb629cb02f029">&#9670;&nbsp;</a></span>horizontal_interval</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;double&gt; base::samples::DepthMap::horizontal_interval</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The interval can describe a position on a planar plane or an angle. The interval is interpreted as defined by the horizontal projection type. In planar projection mode the horizontal intervals are x coordinates on an depth-image plane, with zero in the middle of the plane. In polar projection mode the horizontal intervals are angular rotations around the Z-unit axis. Horizontal angles must always be ordered from a higher to a smaller value, since the columns of the data matrices are interpreted from the left to the right. The field has either two or |horizontal_size| entries. In the case of two entries the intervals are interpreted as left and right boundaries. The transformation for each measurement will be interpolated. </p>

</div>
</div>
<a id="a4d83367c77c4b6214dc18c3a31dda244"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d83367c77c4b6214dc18c3a31dda244">&#9670;&nbsp;</a></span>horizontal_projection</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbase_1_1samples_1_1DepthMap.html#a9c9bd053c2979b78862592d658cc58a7">PROJECTION_TYPE</a> base::samples::DepthMap::horizontal_projection</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Defines the horizontal projection type of the depth map. If polar, the horizontal intervals are angular rotations around the Z-unit axis. If planar, the horizontal intervals are positions on an image plane coordinate frame. </p>

</div>
</div>
<a id="a2a6b0e293816dfc2ebaa4a29668b74bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a6b0e293816dfc2ebaa4a29668b74bc">&#9670;&nbsp;</a></span>horizontal_size</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbase_1_1samples_1_1DepthMap.html#a2746151269e3354cb8ba446d7362b055">uint32_t</a> base::samples::DepthMap::horizontal_size</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Number of horizontal depth samples </p>

</div>
</div>
<a id="aa60ca1cbf9e52b1d5c4861996c6c7073"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa60ca1cbf9e52b1d5c4861996c6c7073">&#9670;&nbsp;</a></span>remissions</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="structbase_1_1samples_1_1DepthMap.html#a6c47293285ef9349f1ce44623ede4206">scalar</a>&gt; base::samples::DepthMap::remissions</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The remission samples. This field is optional. The data is arranged in a row major order to simplify the usage as a remission image. The data for a value (vertical_index, horizontal_index) is in remissions[(vertical_index * horizontal_size) + horizontal_index]. </p>

</div>
</div>
<a id="ae47e3bce314d63cc590183ddf3f1565e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae47e3bce314d63cc590183ddf3f1565e">&#9670;&nbsp;</a></span>time</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbase_1_1Time.html">base::Time</a> base::samples::DepthMap::time</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reference timestamp for the depth map sample. This timestamp is used for temporal alignment to other data samples and transformations. It is important to always set here a meaningful value. </p>

</div>
</div>
<a id="a977af67b71f8d91ad59e2cb3dc38d34b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a977af67b71f8d91ad59e2cb3dc38d34b">&#9670;&nbsp;</a></span>timestamps</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="structbase_1_1Time.html">base::Time</a>&gt; base::samples::DepthMap::timestamps</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The timestamps can be either one timestamp for all measurements, two for interpolation, per vertical entries, per horizontal entries or one per measurement. </p>

</div>
</div>
<a id="a5436e6c2ae542141f15dab930e5d1db1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5436e6c2ae542141f15dab930e5d1db1">&#9670;&nbsp;</a></span>vertical_interval</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;double&gt; base::samples::DepthMap::vertical_interval</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The interval can describe a position on a planar plane or an angle. The interval is interpreted as defined by the vertical projection type. In planar projection mode the vertical intervals are y coordinates on an depth-image plane, with zero in the middle of the plane. In polar projection mode the vertical intervals are angular rotations around the Y-unit axis. Vertical angles must always be ordered from a smaller to a higher value, since the rows of the data matrices are interpreted from the upper to the lower row. The field has either two or |vertical_size| entries. In the case of two entries the intervals are interpreted as upper and under boundaries. The transformation for each measurement will be interpolated. </p>

</div>
</div>
<a id="ab92e02e93419204920914efe882be85d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab92e02e93419204920914efe882be85d">&#9670;&nbsp;</a></span>vertical_projection</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbase_1_1samples_1_1DepthMap.html#a9c9bd053c2979b78862592d658cc58a7">PROJECTION_TYPE</a> base::samples::DepthMap::vertical_projection</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Defines the vertical projection type of the depth map. If polar, the vertical intervals are angular rotations around the Y-unit axis. If planar, the vertical intervals are positions on an image plane coordinate frame. </p>

</div>
</div>
<a id="a37b72bc33d0c0dda95c6d486237b9f78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37b72bc33d0c0dda95c6d486237b9f78">&#9670;&nbsp;</a></span>vertical_size</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbase_1_1samples_1_1DepthMap.html#a2746151269e3354cb8ba446d7362b055">uint32_t</a> base::samples::DepthMap::vertical_size</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Number of vertical depth samples </p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following files:<ul>
<li>/home/dfki.uni-bremen.de/roehr/workspace/2maz/dev/base/types/src/samples/<a class="el" href="DepthMap_8hpp_source.html">DepthMap.hpp</a></li>
<li>/home/dfki.uni-bremen.de/roehr/workspace/2maz/dev/base/types/src/samples/<a class="el" href="DepthMap_8cpp.html">DepthMap.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
